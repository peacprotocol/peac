#!/usr/bin/env npx tsx
/**
 * Profile Generator
 *
 * Generates src/generated/profiles.ts from profiles/*.yaml
 *
 * Requirements:
 * - Deterministic: sorted keys, stable output bytes
 * - Validates: each profile against ProfileDefinitionSchema
 * - No runtime deps: output is pure TS object literals
 *
 * Usage:
 *   npx tsx scripts/generate-profiles.ts         # Generate
 *   npx tsx scripts/generate-profiles.ts --check # Check if up-to-date
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { parse as parseYaml } from 'yaml';
import { ProfileDefinitionSchema, type ProfileDefinition } from '../src/types';

const PROFILES_DIR = path.join(__dirname, '..', 'profiles');
const OUTPUT_FILE = path.join(__dirname, '..', 'src', 'generated', 'profiles.ts');

/**
 * Sort object keys recursively for deterministic output
 */
function sortKeys<T>(obj: T): T {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(sortKeys) as T;
  }

  const sorted: Record<string, unknown> = {};
  const keys = Object.keys(obj as Record<string, unknown>).sort();

  for (const key of keys) {
    sorted[key] = sortKeys((obj as Record<string, unknown>)[key]);
  }

  return sorted as T;
}

/**
 * Convert a value to TypeScript literal string
 */
function toTsLiteral(value: unknown, indent = 0): string {
  const pad = '  '.repeat(indent);
  const padInner = '  '.repeat(indent + 1);

  if (value === null) return 'null';
  if (value === undefined) return 'undefined';
  if (typeof value === 'string') return JSON.stringify(value);
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);

  if (Array.isArray(value)) {
    if (value.length === 0) return '[]';
    const items = value.map((v) => toTsLiteral(v, indent + 1));
    if (items.every((i) => !i.includes('\n')) && items.join(', ').length < 60) {
      return `[${items.join(', ')}]`;
    }
    return `[\n${items.map((i) => `${padInner}${i}`).join(',\n')},\n${pad}]`;
  }

  if (typeof value === 'object') {
    const entries = Object.entries(value as Record<string, unknown>);
    if (entries.length === 0) return '{}';

    const lines = entries.map(([k, v]) => {
      const key = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(k) ? k : JSON.stringify(k);
      return `${padInner}${key}: ${toTsLiteral(v, indent + 1)}`;
    });

    return `{\n${lines.join(',\n')},\n${pad}}`;
  }

  throw new Error(`Unsupported type: ${typeof value}`);
}

/**
 * Load and validate all profile YAML files
 */
function loadProfiles(): Map<string, ProfileDefinition> {
  const profiles = new Map<string, ProfileDefinition>();

  if (!fs.existsSync(PROFILES_DIR)) {
    console.error(`Profiles directory not found: ${PROFILES_DIR}`);
    process.exit(1);
  }

  const files = fs
    .readdirSync(PROFILES_DIR)
    .filter((f) => f.endsWith('.yaml') || f.endsWith('.yml'));

  if (files.length === 0) {
    console.error(`No profile YAML files found in: ${PROFILES_DIR}`);
    process.exit(1);
  }

  // Sort files for deterministic processing
  files.sort();

  for (const file of files) {
    const filePath = path.join(PROFILES_DIR, file);
    const content = fs.readFileSync(filePath, 'utf-8');

    let parsed: unknown;
    try {
      parsed = parseYaml(content);
    } catch (err) {
      console.error(`Failed to parse YAML: ${file}`);
      console.error(err);
      process.exit(1);
    }

    // Validate against schema
    const result = ProfileDefinitionSchema.safeParse(parsed);
    if (!result.success) {
      console.error(`Validation failed for: ${file}`);
      console.error(result.error.format());
      process.exit(1);
    }

    const profile = result.data;
    if (profiles.has(profile.id)) {
      console.error(`Duplicate profile ID: ${profile.id} in ${file}`);
      process.exit(1);
    }

    profiles.set(profile.id, profile);
  }

  return profiles;
}

/**
 * Generate TypeScript source
 */
function generateTs(profiles: Map<string, ProfileDefinition>): string {
  const lines: string[] = [];

  lines.push('/**');
  lines.push(' * Generated Profile Definitions');
  lines.push(' *');
  lines.push(' * DO NOT EDIT MANUALLY - Generated by scripts/generate-profiles.ts');
  lines.push(' * Source: profiles/*.yaml');
  lines.push(' */');
  lines.push('');
  lines.push("import type { ProfileDefinition } from '../types';");
  lines.push('');

  // Sort profile IDs for deterministic output
  const sortedIds = Array.from(profiles.keys()).sort();

  lines.push('/**');
  lines.push(' * Available profile IDs');
  lines.push(' */');
  lines.push(
    `export const PROFILE_IDS = [${sortedIds.map((id) => `'${id}'`).join(', ')}] as const;`
  );
  lines.push('');
  lines.push('export type ProfileId = (typeof PROFILE_IDS)[number];');
  lines.push('');

  lines.push('/**');
  lines.push(' * All profiles indexed by ID');
  lines.push(' */');
  lines.push('export const PROFILES: Record<ProfileId, ProfileDefinition> = {');

  for (const id of sortedIds) {
    const profile = profiles.get(id)!;
    // Sort keys for deterministic output
    const sorted = sortKeys(profile);
    lines.push(`  '${id}': ${toTsLiteral(sorted, 1)},`);
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

/**
 * Main entry point
 */
function main() {
  const checkMode = process.argv.includes('--check');

  console.log('Loading profiles...');
  const profiles = loadProfiles();
  console.log(`Found ${profiles.size} profiles: ${Array.from(profiles.keys()).join(', ')}`);

  console.log('Generating TypeScript...');
  const generated = generateTs(profiles);

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  if (checkMode) {
    // Check if existing file matches
    if (!fs.existsSync(OUTPUT_FILE)) {
      console.error(`Output file does not exist: ${OUTPUT_FILE}`);
      console.error('Run without --check to generate.');
      process.exit(1);
    }

    const existing = fs.readFileSync(OUTPUT_FILE, 'utf-8');
    if (existing !== generated) {
      console.error('Generated profiles are out of date!');
      console.error('Run: pnpm --filter @peac/policy-kit generate:profiles');
      process.exit(1);
    }

    console.log('Generated profiles are up to date.');
  } else {
    fs.writeFileSync(OUTPUT_FILE, generated, 'utf-8');
    console.log(`Written to: ${OUTPUT_FILE}`);
  }
}

main();
