/**
 * Bundle Vector Conformance Tests
 *
 * These tests load real ZIP bundles from specs/conformance/fixtures/bundle/vectors/
 * and verify that:
 * 1. Valid bundles produce deterministic report hashes
 * 2. Invalid bundles produce expected error codes
 *
 * The vectors are generated by scripts/generate-bundle-vectors.ts and should be
 * regenerated when bundle format or verification logic changes.
 */

import { describe, it, expect, beforeAll } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import { verifyBundle } from '../src/verification-report';

const VECTORS_DIR = path.join(__dirname, '../../../specs/conformance/fixtures/bundle/vectors');
const EXPECTED_DIR = path.join(__dirname, '../../../specs/conformance/fixtures/bundle/expected');

interface VectorManifestEntry {
  vector_id: string;
  file: string;
  expected_valid: boolean;
  expected_report_hash_file?: string;
  expected_receipt_error?: string;
  expected_error?: string;
  expected_error_file?: string;
  description?: string;
}

interface VectorManifest {
  version: string;
  description: string;
  vectors: VectorManifestEntry[];
}

describe('Bundle Vector Conformance', () => {
  let manifest: VectorManifest;

  beforeAll(() => {
    const manifestPath = path.join(VECTORS_DIR, 'manifest.json');
    if (!fs.existsSync(manifestPath)) {
      throw new Error('Vector manifest not found. Run: npx tsx scripts/generate-bundle-vectors.ts');
    }
    manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
  });

  describe('Valid Bundles', () => {
    it('valid_minimal: should verify with deterministic report hash', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'valid_minimal');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(true);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedHashPath = path.join(EXPECTED_DIR, vector!.expected_report_hash_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedHash = fs.readFileSync(expectedHashPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.value.summary.valid).toBe(result.value.summary.total_receipts);
        expect(result.value.summary.invalid).toBe(0);
        expect(result.value.report_hash).toBe(expectedHash);
        expect(result.value.auditor_summary.recommendation).toBe('valid');
      }
    });

    it('valid_multi_receipt: should verify with deterministic report hash', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'valid_multi_receipt');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(true);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedHashPath = path.join(EXPECTED_DIR, vector!.expected_report_hash_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedHash = fs.readFileSync(expectedHashPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.value.summary.total_receipts).toBe(3);
        expect(result.value.summary.valid).toBe(3);
        expect(result.value.summary.invalid).toBe(0);
        expect(result.value.report_hash).toBe(expectedHash);
        expect(result.value.auditor_summary.recommendation).toBe('valid');
      }
    });
  });

  describe('Invalid Bundles', () => {
    it('invalid_signature: should detect invalid Ed25519 signature', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'invalid_signature');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(false);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedErrorPath = path.join(EXPECTED_DIR, vector!.expected_error_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedError = fs.readFileSync(expectedErrorPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      // Bundle reads successfully but verification finds invalid signatures
      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.value.summary.invalid).toBeGreaterThan(0);
        const invalidReceipt = result.value.receipts.find((r) => !r.signature_valid);
        expect(invalidReceipt).toBeDefined();
        expect(invalidReceipt!.errors).toContain(expectedError);
        expect(result.value.auditor_summary.recommendation).toBe('invalid');
      }
    });

    it('missing_key: should detect missing verification key', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'missing_key');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(false);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedErrorPath = path.join(EXPECTED_DIR, vector!.expected_error_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedError = fs.readFileSync(expectedErrorPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      // Bundle reads successfully but verification finds missing key
      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.value.summary.invalid).toBeGreaterThan(0);
        const invalidReceipt = result.value.receipts.find((r) => !r.signature_valid);
        expect(invalidReceipt).toBeDefined();
        expect(invalidReceipt!.errors).toContain(expectedError);
        expect(result.value.auditor_summary.recommendation).toBe('invalid');
      }
    });
  });

  describe('Security Vectors', () => {
    it('path_traversal_unix: should reject zip-slip attack with ../', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'path_traversal_unix');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(false);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedErrorPath = path.join(EXPECTED_DIR, vector!.expected_error_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedError = fs.readFileSync(expectedErrorPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      // Should fail early during parsing due to unsafe path
      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error.code).toBe(expectedError);
      }
    });

    it('path_traversal_windows: should reject zip-slip attack with ..\\', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'path_traversal_windows');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(false);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedErrorPath = path.join(EXPECTED_DIR, vector!.expected_error_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedError = fs.readFileSync(expectedErrorPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      // Should fail early during parsing due to unsafe path (backslash detection)
      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error.code).toBe(expectedError);
      }
    });

    it('duplicate_receipt: should reject bundle with duplicate jti', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'duplicate_receipt');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(false);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedErrorPath = path.join(EXPECTED_DIR, vector!.expected_error_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedError = fs.readFileSync(expectedErrorPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      // Should fail during verification when duplicate jti is detected
      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error.code).toBe(expectedError);
      }
    });

    it('size_exceeded: should reject bundle with falsely large size claim', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'size_exceeded');
      expect(vector).toBeDefined();
      expect(vector!.expected_valid).toBe(false);

      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const expectedErrorPath = path.join(EXPECTED_DIR, vector!.expected_error_file!);

      const zipBuffer = fs.readFileSync(zipPath);
      const expectedError = fs.readFileSync(expectedErrorPath, 'utf8').trim();

      const result = await verifyBundle(zipBuffer, { offline: true });

      // Should fail early due to DoS protection (checks size before decompressing)
      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error.code).toBe(expectedError);
      }
    });
  });

  describe('Determinism', () => {
    it('should produce identical report hash for same bundle verified twice', async () => {
      const vector = manifest.vectors.find((v) => v.vector_id === 'valid_minimal');
      const zipPath = path.join(VECTORS_DIR, vector!.file);
      const zipBuffer = fs.readFileSync(zipPath);

      const result1 = await verifyBundle(zipBuffer, { offline: true });
      const result2 = await verifyBundle(zipBuffer, { offline: true });

      expect(result1.ok).toBe(true);
      expect(result2.ok).toBe(true);
      if (result1.ok && result2.ok) {
        expect(result1.value.report_hash).toBe(result2.value.report_hash);
      }
    });
  });
});
